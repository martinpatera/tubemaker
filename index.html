<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TUBEMAKER™ – 3D konfigurátor (MVP)</title>
  <style>
    :root{
      --bg:#ffffff;
      --panel:#ffffff;
      --text:#111827;
      --muted:#6b7280;
      --accent:#0619f5;
      --card: rgba(17,24,39,.03);
      --border: rgba(17,24,39,.12);
      --shadow: 0 10px 30px rgba(0,0,0,.08);
    }
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    .wrap{
      display:grid;
      grid-template-columns: 360px 1fr;
      height:100vh;
    }
    .panel{
      padding:18px;
      background:var(--panel);
      border-right:1px solid var(--border);
      overflow:auto;
    }
    .brand{
      display:flex;
      gap:10px;
      align-items:baseline;
      margin-bottom:14px;
    }
    .brand h1{
      margin:0;
      font-size:18px;
      letter-spacing:.2px;
      font-weight:650;
    }
    .brand .sub{
      font-size:12px;
      color:var(--muted);
    }

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      padding:14px;
      margin:12px 0;
      box-shadow: var(--shadow);
    }

    .row{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
      margin:10px 0;
    }
    label{ font-size:12px; color:var(--muted); }
    .value{
      font-variant-numeric: tabular-nums;
      text-align:right;
      font-size:12px;
      color:var(--text);
    }

    .row.range input[type="range"]{
      grid-column: 1 / -1;
      width:100%;
    }

    select,input[type="color"],button{ width:100%; }
    input[type="range"]{ accent-color: var(--accent); }
    select,button,input[type="color"]{
      background:#fff;
      border:1px solid var(--border);
      color:var(--text);
      border-radius:10px;
      padding:10px;
      box-shadow: 0 2px 10px rgba(0,0,0,.04);
    }
    button{ cursor:pointer; }
    button.primary{
      background:var(--accent);
      border-color:transparent;
      color:#fff;
      font-weight:650;
    }

    .tiny{ font-size:11px; color:var(--muted); line-height:1.35; }

    .canvas{
      position:relative;
      height:100%;
      background:#fff;
    }
    #c{ width:100%; height:100%; display:block; }

    .hudBottom{
      position:absolute;
      left:50%;
      bottom:14px;
      transform:translateX(-50%);
      background:rgba(255,255,255,.86);
      border:1px solid var(--border);
      backdrop-filter: blur(10px);
      border-radius:14px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      max-width:min(840px, calc(100% - 24px));
      font-size:12px;
      color:var(--muted);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
      align-items:center;
    }
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(17,24,39,.03);
      border:1px solid var(--border);
      color:var(--text);
      font-size:12px;
    }
    .pill b{ color:var(--text); }

    @media (max-width: 920px){
      .wrap{
        grid-template-columns: 1fr;
        grid-template-rows:auto 1fr;
      }
      .panel{
        border-right:none;
        border-bottom:1px solid var(--border);
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel">
      <div class="brand">
        <h1>tubemaker™</h1>
        <div class="sub">3D konfigurátor (MVP)</div>
      </div>

      <div class="card">
        <div class="row">
          <label for="type">Typ konstrukce</label>
          <select id="type">
            <option value="one">Jednodílný</option>
            <option value="two" selected>Spodek &amp; víko</option>
            <option value="tel">Teleskopický</option>
          </select>
        </div>

        <div class="row range">
          <label for="diameter">Průměr (mm)</label>
          <div class="value" id="diameterVal"></div>
          <input id="diameter" type="range" min="35" max="120" step="1" value="70" />
        </div>

        <div class="row range">
          <label for="height">Celková výška (mm)</label>
          <div class="value" id="heightVal"></div>
          <input id="height" type="range" min="50" max="500" step="1" value="153" />
        </div>

        <div class="row range" id="telRow">
          <label for="telLidPct">Teleskop: výška víka</label>
          <div class="value" id="telLidPctVal"></div>
          <input id="telLidPct" type="range" min="20" max="85" step="1" value="45" />
        </div>

        <div class="row range">
          <label for="open">Otevření</label>
          <div class="value" id="openVal"></div>
          <input id="open" type="range" min="0" max="100" step="1" value="0" />
        </div>
      </div>

      <div class="card">
        <div class="row">
          <label for="material">Povrch</label>
          <select id="material">
            <option value="paper" selected>Matný papír</option>
            <option value="satin">Satén</option>
            <option value="metal">Metalický</option>
          </select>
        </div>

        <div class="row">
          <label for="color">Barva</label>
          <input id="color" type="color" value="#FEC700" />
        </div>

        <div class="row" style="grid-template-columns:1fr 1fr;">
          <button id="reset">Reset view</button>
          <button id="copy" class="primary">Copy config JSON</button>
        </div>

        <div class="tiny">Ovládání: myší otáčej · kolečkem zoom · pravým tlačítkem posuň</div>
        <div class="tiny">Prodejní vizualizace — ne výrobní CAD.</div>
      </div>

      <div class="card">
        <div class="tiny">
          <b>Detail realismu (nastavit v kódu):</b><br>
          Stěna papíru: 1.5 mm · Curled edge: zapnutý pro spodek & víko + teleskop · Plechové víčko: tenký “cup”.
        </div>
      </div>
    </div>

    <div class="canvas">
      <canvas id="c"></canvas>
      <div class="hudBottom" id="hudBottom"></div>
    </div>
  </div>

  <script type="module">
    // ---- Imports (GitHub Pages friendly) ----
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js?module";

    // ---- “Realism” constants (mm-ish units) ----
    const WALL_MM = 1.5;               // papír / lepenka: tloušťka stěny (viditelný dutý profil)
    const PAPER_CURL_R = 2.2;          // radius curled edge (papír)
    const LID_CLEARANCE_MM = 0.8;      // vůle (aby víko reálně "šlo nasadit")
    const METAL_SHEET_MM = 0.6;        // tloušťka plechu (tenké víčko)
    const METAL_CAP_H_MM = 10;         // “hloubka” plechového víčka (výška boční stěny víčka)
    const METAL_CURL_R = 0.95;         // jemný roll na hraně plechu (aby to nevypadalo jako špalek)
    const RADIAL_SEG = 140;            // hladký kruh
    const SHADOW_OPACITY = 0.20;

    // ---- DOM ----
    const $ = (id) => document.getElementById(id);
    const ui = {
      type: $("type"),
      diameter: $("diameter"),
      height: $("height"),
      telRow: $("telRow"),
      telLidPct: $("telLidPct"),
      open: $("open"),
      material: $("material"),
      color: $("color"),
      reset: $("reset"),
      copy: $("copy"),

      diameterVal: $("diameterVal"),
      heightVal: $("heightVal"),
      telLidPctVal: $("telLidPctVal"),
      openVal: $("openVal"),

      hudBottom: $("hudBottom"),
    };

    const mm = (n)=> `${Math.round(n)} mm`;
    const pct = (n)=> `${Math.round(n)}%`;

    // ---- Three setup ----
    const canvas = $("c");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0xffffff, 1);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 6000);
    camera.position.set(260, 220, 360);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    // Lights (white studio)
    scene.add(new THREE.HemisphereLight(0xffffff, 0xf3f4f6, 0.9));

    const key = new THREE.DirectionalLight(0xffffff, 0.9);
    key.position.set(500, 800, 300);
    key.castShadow = true;
    key.shadow.mapSize.set(2048, 2048);
    key.shadow.camera.near = 10;
    key.shadow.camera.far = 2500;
    key.shadow.camera.left = -700;
    key.shadow.camera.right = 700;
    key.shadow.camera.top = 700;
    key.shadow.camera.bottom = -700;
    scene.add(key);

    const fill = new THREE.DirectionalLight(0xffffff, 0.35);
    fill.position.set(-450, 260, -380);
    scene.add(fill);

    // Shadow catcher plane
    const shadowPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(2400, 2400),
      new THREE.ShadowMaterial({ opacity: SHADOW_OPACITY })
    );
    shadowPlane.rotation.x = -Math.PI/2;
    shadowPlane.position.y = -0.15; // tiny offset to avoid z-fighting
    shadowPlane.receiveShadow = true;
    scene.add(shadowPlane);

    const root = new THREE.Group();
    scene.add(root);

    // We only need to animate lifting parts; store references:
    const parts = {
      base: null,
      lid: null,
      collar: null,
      metalTop: null,
      metalBottom: null,
      type: "two",
      dims: null,
    };

    // ---- Helpers ----
    function disposeObject(obj){
      obj.traverse(o=>{
        if(o.geometry) o.geometry.dispose();
        if(o.material){
          if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose());
          else o.material.dispose();
        }
      });
    }

    function clearRoot(){
      while(root.children.length){
        const ch = root.children[0];
        disposeObject(ch);
        root.remove(ch);
      }
      parts.base = parts.lid = parts.collar = parts.metalTop = parts.metalBottom = null;
    }

    function makeWrapMaterials(kind, hex){
      const c = new THREE.Color(hex);
      let metalness = 0.0, roughness = 0.78;
      if(kind === "satin"){ metalness = 0.05; roughness = 0.35; }
      if(kind === "metal"){ metalness = 0.72; roughness = 0.22; }

      const outer = new THREE.MeshStandardMaterial({
        color: c, metalness, roughness, side: THREE.FrontSide
      });

      const inner = new THREE.MeshStandardMaterial({
        color: c.clone().multiplyScalar(0.92),
        metalness: metalness * 0.55,
        roughness: Math.min(1, roughness + 0.10),
        side: THREE.BackSide
      });

      const edge = new THREE.MeshStandardMaterial({
        color: c.clone().multiplyScalar(0.98),
        metalness,
        roughness: Math.min(1, roughness + 0.06),
        side: THREE.DoubleSide
      });

      return { outer, inner, edge };
    }

    function makeMetalMaterials(hex = "#d7dbe3"){
      const c = new THREE.Color(hex);
      const outer = new THREE.MeshStandardMaterial({
        color: c, metalness: 0.88, roughness: 0.24, side: THREE.FrontSide
      });
      const inner = new THREE.MeshStandardMaterial({
        color: c.clone().multiplyScalar(0.86),
        metalness: 0.88,
        roughness: 0.32,
        side: THREE.BackSide
      });
      const edge = new THREE.MeshStandardMaterial({
        color: c, metalness: 0.9, roughness: 0.24, side: THREE.DoubleSide
      });
      return { outer, inner, edge };
    }

    // Hollow tube with visible wall thickness + optional curled edge on open rims
    function makeHollowTube({
      rOut, height, wall,
      mats,
      openTop=true, openBottom=true,
      closedTop=false, closedBottom=false,
      curlTop=false, curlBottom=false,
      curlR=PAPER_CURL_R
    }){
      const g = new THREE.Group();
      g.userData.height = height;

      const rIn = Math.max(0.1, rOut - wall);
      const innerH = Math.max(0.1, height - 2*wall);

      const outerWall = new THREE.Mesh(
        new THREE.CylinderGeometry(rOut, rOut, height, RADIAL_SEG, 1, true),
        mats.outer
      );
      outerWall.position.y = height/2;
      outerWall.castShadow = true;
      g.add(outerWall);

      const innerWall = new THREE.Mesh(
        new THREE.CylinderGeometry(rIn, rIn, innerH, RADIAL_SEG, 1, true),
        mats.inner
      );
      innerWall.position.y = height/2;
      innerWall.castShadow = false;
      g.add(innerWall);

      // Rims (flat ring showing thickness)
      if(openTop && !closedTop){
        const ringTop = new THREE.Mesh(
          new THREE.RingGeometry(rIn, rOut, RADIAL_SEG),
          mats.edge
        );
        ringTop.rotation.x = -Math.PI/2;
        ringTop.position.y = height;
        ringTop.castShadow = true;
        g.add(ringTop);
      }
      if(openBottom && !closedBottom){
        const ringBot = new THREE.Mesh(
          new THREE.RingGeometry(rIn, rOut, RADIAL_SEG),
          mats.edge
        );
        ringBot.rotation.x = -Math.PI/2;
        ringBot.position.y = 0;
        ringBot.castShadow = true;
        g.add(ringBot);
      }

      // Caps (paper discs)
      if(closedBottom){
        const capB = new THREE.Mesh(
          new THREE.CylinderGeometry(rOut, rOut, wall, RADIAL_SEG),
          mats.edge
        );
        capB.position.y = wall/2;
        capB.castShadow = true;
        g.add(capB);
      }
      if(closedTop){
        const capT = new THREE.Mesh(
          new THREE.CylinderGeometry(rOut, rOut, wall, RADIAL_SEG),
          mats.edge
        );
        capT.position.y = height - wall/2;
        capT.castShadow = true;
        g.add(capT);
      }

      // Curled edges (visual roll on open rims)
      if(curlTop && openTop && !closedTop){
        const tor = new THREE.Mesh(
          new THREE.TorusGeometry(Math.max(0.1, rOut - curlR), curlR, 18, RADIAL_SEG),
          mats.outer
        );
        tor.rotation.x = Math.PI/2;
        tor.position.y = height - curlR;
        tor.castShadow = true;
        g.add(tor);
      }
      if(curlBottom && openBottom && !closedBottom){
        const tor = new THREE.Mesh(
          new THREE.TorusGeometry(Math.max(0.1, rOut - curlR), curlR, 18, RADIAL_SEG),
          mats.outer
        );
        tor.rotation.x = Math.PI/2;
        tor.position.y = curlR;
        tor.castShadow = true;
        g.add(tor);
      }

      return g;
    }

    // Sheet-metal cap: a thin "cup" (really looks like plech, not thick plastic)
    function makeMetalCap({
      rTubeOut,
      capH = METAL_CAP_H_MM,
      sheet = METAL_SHEET_MM,
      clearance = LID_CLEARANCE_MM,
      closedAt = "top", // "top" for lid, "bottom" for bottom-end
      curlR = METAL_CURL_R,
      mats = makeMetalMaterials()
    }){
      const g = new THREE.Group();
      g.userData.height = capH;

      const rIn = rTubeOut + clearance;      // fits over tube
      const rOut = rIn + sheet;              // sheet thickness outward

      // Outer wall
      const outerWall = new THREE.Mesh(
        new THREE.CylinderGeometry(rOut, rOut, capH, RADIAL_SEG, 1, true),
        mats.outer
      );
      outerWall.position.y = capH/2;
      outerWall.castShadow = true;
      g.add(outerWall);

      // Inner wall (slightly shorter to avoid z-fight with the disk)
      const innerH = Math.max(0.1, capH - sheet);
      const innerWall = new THREE.Mesh(
        new THREE.CylinderGeometry(rIn, rIn, innerH, RADIAL_SEG, 1, true),
        mats.inner
      );
      if(closedAt === "top"){
        innerWall.position.y = innerH/2; // from 0..(capH-sheet)
      } else {
        innerWall.position.y = sheet + innerH/2; // from sheet..capH
      }
      g.add(innerWall);

      // Closed disk
      const disk = new THREE.Mesh(
        new THREE.CylinderGeometry(rOut, rOut, sheet, RADIAL_SEG),
        mats.edge
      );
      disk.castShadow = true;

      // Open rim ring
      const rimRing = new THREE.Mesh(
        new THREE.RingGeometry(rIn, rOut, RADIAL_SEG),
        mats.edge
      );
      rimRing.rotation.x = -Math.PI/2;
      rimRing.castShadow = true;

      // Tiny rolled edge on the open rim (so it doesn't look like a razor edge)
      const roll = new THREE.Mesh(
        new THREE.TorusGeometry(Math.max(0.1, rOut - curlR), curlR, 16, RADIAL_SEG),
        mats.outer
      );
      roll.rotation.x = Math.PI/2;
      roll.castShadow = true;

      if(closedAt === "top"){
        disk.position.y = capH - sheet/2;
        rimRing.position.y = 0;
        roll.position.y = curlR;
      } else {
        disk.position.y = sheet/2;
        rimRing.position.y = capH;
        roll.position.y = capH - curlR;
      }

      g.add(disk, rimRing, roll);
      return g;
    }

    function setClosedY(obj, y){
      obj.userData.closedY = y;
      obj.position.y = y;
    }

    function currentConfig(){
      return {
        type: ui.type.value,
        diameterMm: Number(ui.diameter.value),
        heightMm: Number(ui.height.value),
        telLidPct: Number(ui.telLidPct.value),
        openPct: Number(ui.open.value),
        material: ui.material.value,
        colorHex: ui.color.value,
        wallMm: WALL_MM
      };
    }

    function syncLabels(){
      ui.diameterVal.textContent = mm(ui.diameter.value);
      ui.heightVal.textContent = mm(ui.height.value);
      ui.telLidPctVal.textContent = pct(ui.telLidPct.value);
      ui.openVal.textContent = pct(ui.open.value);
      ui.telRow.style.display = (ui.type.value === "tel") ? "block" : "none";
    }

    function updateHUD(){
      const cfg = currentConfig();
      const typeLabel = cfg.type === "one" ? "Jednodílný" : (cfg.type === "two" ? "Spodek & víko" : "Teleskopický");
      const matLabel = cfg.material === "paper" ? "Matný" : (cfg.material === "satin" ? "Satén" : "Metal");
      const extra = cfg.type === "tel" ? ` · <b>Víko:</b> ${cfg.telLidPct}%` : "";
      ui.hudBottom.innerHTML = `
        <span class="pill"><b>Typ</b> ${typeLabel}</span>
        <span class="pill"><b>Ø</b> ${cfg.diameterMm} mm</span>
        <span class="pill"><b>Výška</b> ${cfg.heightMm} mm</span>
        <span class="pill"><b>Povrch</b> ${matLabel}</span>
        <span class="pill"><b>Barva</b> ${cfg.colorHex.toUpperCase()}</span>
        <span class="pill"><b>Otevření</b> ${cfg.openPct}%${extra}</span>
      `;
    }

    function resize(){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      if(w <= 0 || h <= 0) return;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }

    function buildModel(){
      clearRoot();

      const type = ui.type.value;
      const D = Number(ui.diameter.value);
      const H = Number(ui.height.value);
      const r = D/2;

      parts.type = type;

      const wrapMats = makeWrapMaterials(ui.material.value, ui.color.value);
      const metalMats = makeMetalMaterials("#D7DBE3");

      // A small “stage” offset so it sits nicely above shadow plane
      const y0 = 0;

      if(type === "one"){
        // Paper tube body (hollow)
        const body = makeHollowTube({
          rOut: r,
          height: H,
          wall: WALL_MM,
          mats: wrapMats,
          openTop: true,
          openBottom: true,
          closedTop: false,
          closedBottom: false,
          curlTop: false,
          curlBottom: false
        });
        body.position.y = y0;
        root.add(body);
        parts.base = body;

        // Bottom metal end-cap (closed at bottom, open at top)
        const bottomCap = makeMetalCap({
          rTubeOut: r,
          capH: Math.max(8, Math.min(14, D*0.14)),
          sheet: METAL_SHEET_MM,
          clearance: 0.6,
          closedAt: "bottom",
          curlR: METAL_CURL_R,
          mats: metalMats
        });
        // put it on the ground; it wraps upward a bit
        bottomCap.position.y = y0;
        root.add(bottomCap);
        parts.metalBottom = bottomCap;

        // Top metal lid (closed at top, open at bottom) – lifts when opening
        const topCap = makeMetalCap({
          rTubeOut: r,
          capH: Math.max(9, Math.min(16, D*0.16)),
          sheet: METAL_SHEET_MM,
          clearance: 0.6,
          closedAt: "top",
          curlR: METAL_CURL_R,
          mats: metalMats
        });

        // overlap so it “sits on” the tube (realistic)
        const overlap = Math.max(6, Math.min(14, D*0.12));
        const closedY = y0 + H - overlap;
        setClosedY(topCap, closedY);

        root.add(topCap);
        parts.metalTop = topCap;

        // Aim controls at mid-height
        controls.target.set(0, H*0.55, 0);
      }

      if(type === "two"){
        // Choose proportions so closed total = H, with overlap
        const lidH = Math.max(35, Math.min(H*0.42, 140));
        const overlap = Math.max(14, Math.min(H*0.18, 40));
        const baseH = Math.max(35, H - lidH + overlap);

        // Base: open top with curled edge, closed bottom
        const base = makeHollowTube({
          rOut: r,
          height: baseH,
          wall: WALL_MM,
          mats: wrapMats,
          openTop: true,
          openBottom: false,
          closedBottom: true,
          curlTop: true,
          curlBottom: false,
          curlR: PAPER_CURL_R
        });
        base.position.y = y0;
        root.add(base);
        parts.base = base;

        // Lid: slightly bigger radius so it really fits over the base
        const rLid = r + (WALL_MM + LID_CLEARANCE_MM + 0.2);
        const lid = makeHollowTube({
          rOut: rLid,
          height: lidH,
          wall: WALL_MM,
          mats: wrapMats,
          openTop: false,
          openBottom: true,
          closedTop: true,
          curlBottom: true,
          curlR: PAPER_CURL_R
        });

        const closedY = y0 + (baseH - overlap);
        setClosedY(lid, closedY);
        root.add(lid);
        parts.lid = lid;

        // Aim controls
        controls.target.set(0, H*0.55, 0);
      }

      if(type === "tel"){
        // Lid height is user-controlled (%)
        const lidPct = Number(ui.telLidPct.value)/100;
        const lidH = Math.max(40, Math.min(H*lidPct, 320));
        const overlap = Math.max(16, Math.min(lidH*0.18, 55));
        const lowerVisible = Math.max(35, H - lidH + overlap); // base + visible neck when opened

        const baseH = Math.max(35, lowerVisible*0.72);
        const neckAbove = Math.max(12, lowerVisible - baseH);
        const neckInsert = Math.max(18, Math.min(baseH*0.45, 65));
        const neckH = neckAbove + neckInsert;

        // Base (open top with curl, closed bottom)
        const base = makeHollowTube({
          rOut: r,
          height: baseH,
          wall: WALL_MM,
          mats: wrapMats,
          openTop: true,
          openBottom: false,
          closedBottom: true,
          curlTop: true,
          curlR: PAPER_CURL_R
        });
        base.position.y = y0;
        root.add(base);
        parts.base = base;

        // Inner neck (krček) – slightly smaller, sits inside and protrudes above the base
        const neckR = Math.max(2, (r - WALL_MM - 1.1));
        const collar = makeHollowTube({
          rOut: neckR,
          height: neckH,
          wall: Math.max(1.0, WALL_MM*0.9),
          mats: wrapMats,
          openTop: true,
          openBottom: true,
          closedTop: false,
          closedBottom: false,
          curlTop: false,
          curlBottom: false
        });
        // Position so it goes into base and also rises above it
        collar.position.y = y0 + (baseH - neckInsert);
        root.add(collar);
        parts.collar = collar;

        // Outer lid (bigger so it slides over base)
        const rLid = r + (WALL_MM + LID_CLEARANCE_MM + 0.4);
        const lid = makeHollowTube({
          rOut: rLid,
          height: lidH,
          wall: WALL_MM,
          mats: wrapMats,
          openTop: false,
          openBottom: true,
          closedTop: true,
          curlBottom: true,
          curlR: PAPER_CURL_R
        });

        const closedY = y0 + (lowerVisible - overlap);
        setClosedY(lid, closedY);
        root.add(lid);
        parts.lid = lid;

        controls.target.set(0, H*0.55, 0);
      }

      applyOpen();
      updateHUD();
      resize();
    }

    function applyOpen(){
      const open = Number(ui.open.value)/100;
      const cfg = currentConfig();

      // Reset moved parts to closed position, then lift
      if(parts.type === "one" && parts.metalTop){
        const D = cfg.diameterMm;
        const H = cfg.heightMm;
        const maxLift = Math.max(60, Math.min(H*0.7, 260));
        parts.metalTop.position.y = parts.metalTop.userData.closedY + open * maxLift;
      }

      if(parts.type === "two" && parts.lid){
        const H = cfg.heightMm;
        const maxLift = Math.max(70, Math.min(H*0.75, 320));
        parts.lid.position.y = parts.lid.userData.closedY + open * maxLift;
      }

      if(parts.type === "tel" && parts.lid){
        const H = cfg.heightMm;
        const maxLift = Math.max(90, Math.min(H*0.85, 380));
        parts.lid.position.y = parts.lid.userData.closedY + open * maxLift;
      }
    }

    function rebuild(){
      syncLabels();
      buildModel();
      renderer.render(scene, camera);
    }

    // ---- UI events ----
    ["input","change"].forEach(evt=>{
      ui.type.addEventListener(evt, rebuild);
      ui.diameter.addEventListener(evt, rebuild);
      ui.height.addEventListener(evt, rebuild);
      ui.telLidPct.addEventListener(evt, rebuild);
      ui.material.addEventListener(evt, rebuild);
      ui.color.addEventListener(evt, rebuild);

      // open should NOT rebuild geometry every time; just move parts
      ui.open.addEventListener(evt, () => {
        syncLabels();
        applyOpen();
        updateHUD();
      });
    });

    ui.reset.addEventListener("click", () => {
      // Nice, consistent framing
      const cfg = currentConfig();
      const r = cfg.diameterMm/2;
      const H = cfg.heightMm;

      controls.target.set(0, H*0.55, 0);
      camera.position.set(r*5.2, H*1.1, r*6.2);
      controls.update();
      resize();
    });

    ui.copy.addEventListener("click", async () => {
      const payload = { ...currentConfig(), timestamp: new Date().toISOString() };
      const json = JSON.stringify(payload, null, 2);
      try{
        await navigator.clipboard.writeText(json);
        ui.copy.textContent = "Copied ✓";
        setTimeout(()=> ui.copy.textContent = "Copy config JSON", 900);
      }catch(e){
        window.prompt("Copy JSON:", json);
      }
    });

    window.addEventListener("resize", () => {
      resize();
    });

    // ---- Init ----
    syncLabels();
    buildModel();
    resize();

    // Force a few renders after layout settles (iframes / Squarespace love this)
    setTimeout(()=>{ resize(); }, 120);
    setTimeout(()=>{ resize(); }, 420);
    setTimeout(()=>{ resize(); }, 900);

    // Single render loop
    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
