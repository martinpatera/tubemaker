<!-- TUBEMAKER™ 3D Configurator (Squarespace embed) -->
<div id="tm-embed" class="tm-embed">
  <div class="tm-wrap">
    <div class="tm-panel">
      <div class="tm-brand">
        <h1>tubemaker™</h1>
        <div class="tm-sub">3D configurator (BETA)</div>
      </div>

      <div class="tm-card">
        <div class="tm-row">
          <label for="tm-type">Construction type</label>
          <select id="tm-type">
            <option value="one">One-piece</option>
            <option value="two" selected>Base &amp; lid</option>
            <option value="tel">Telescopic</option>
          </select>
        </div>

        <div class="tm-row tm-range">
          <label for="tm-diameter">Diameter (mm)</label>
          <div class="tm-value" id="tm-diameterVal"></div>
          <input id="tm-diameter" type="range" min="35" max="120" step="1" value="70" />
        </div>

        <div class="tm-row tm-range">
          <label for="tm-height">Total height (mm)</label>
          <div class="tm-value" id="tm-heightVal"></div>
          <input id="tm-height" type="range" min="50" max="500" step="1" value="153" />
        </div>

        <div class="tm-row tm-range" id="tm-telRow">
          <label for="tm-telLidPct">Telescopic: lid height</label>
          <div class="tm-value" id="tm-telLidPctVal"></div>
          <input id="tm-telLidPct" type="range" min="20" max="85" step="1" value="45" />
        </div>

        <div class="tm-row tm-range">
          <label for="tm-open">Opening</label>
          <div class="tm-value" id="tm-openVal"></div>
          <input id="tm-open" type="range" min="0" max="100" step="1" value="0" />
        </div>
      </div>

      <div class="tm-card">
        <div class="tm-row">
          <label for="tm-material">Finish</label>
          <select id="tm-material">
            <option value="paper" selected>Matte paper</option>
            <option value="satin">Satin</option>
            <option value="metal">Metallic</option>
          </select>
        </div>

        <div class="tm-row">
          <label for="tm-color">Color</label>
          <input id="tm-color" type="color" value="#FEC700" />
        </div>

        <div class="tm-row tm-twoBtns">
          <button id="tm-reset" type="button">Reset view</button>
          <button id="tm-copy" type="button" class="tm-primary">Copy configuration JSON</button>
        </div>

        <div class="tm-tiny">Controls: rotate with mouse · wheel/trackpad to zoom · right-click to pan</div>
        <div class="tm-tiny">Sales visualization — not production CAD.</div>
      </div>

      <!-- ✅ SUMMARY moved into the left panel -->
      <div class="tm-card">
        <div class="tm-summaryTitle">Summary</div>
        <div class="tm-hudBottom" id="tm-hudBottom"></div>
      </div>

      <div class="tm-card">
        <div class="tm-tiny">
          <b>Realism details (set in code):</b><br>
          Paper wall: 1.5 mm · Curled edge: outside rim on base &amp; lid (2‑piece + telescopic) · One‑piece metal end‑caps: ultra‑thin (~1 mm) hint.
        </div>
      </div>
    </div>

    <div class="tm-canvas">
      <canvas id="tm-c"></canvas>
      <!-- ✅ HUD removed from canvas -->
    </div>
  </div>
</div>

<style>
  /* ===== Scoped styles (won't touch the rest of Squarespace) ===== */
  .tm-embed{
    --tm-height: 900px;

    --bg:#ffffff;
    --panel:#ffffff;
    --text:#111827;
    --muted:#6b7280;
    --accent:#0619f5;
    --card: rgba(17,24,39,.03);
    --border: rgba(17,24,39,.12);
    --shadow: 0 10px 30px rgba(0,0,0,.08);

    width:100%;
    color:var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  }
  .tm-embed, .tm-embed *{ box-sizing:border-box; }

  .tm-embed .tm-wrap{
    display:grid;
    grid-template-columns: 360px 1fr;
    height: min(var(--tm-height), 85vh);
    min-height: 720px;

    background:var(--bg);
    border:1px solid var(--border);
    border-radius:16px;
    overflow:hidden;
  }

  .tm-embed .tm-panel{
    padding:18px;
    background:var(--panel);
    border-right:1px solid var(--border);
    overflow:auto;
  }

  .tm-embed .tm-brand{
    display:flex;
    gap:10px;
    align-items:baseline;
    margin-bottom:14px;
  }
  .tm-embed .tm-brand h1{
    margin:0;
    font-size:18px;
    letter-spacing:.2px;
    font-weight:650;
  }
  .tm-embed .tm-sub{ font-size:12px; color:var(--muted); }

  .tm-embed .tm-card{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:14px;
    padding:14px;
    margin:12px 0;
    box-shadow: var(--shadow);
  }

  .tm-embed .tm-row{
    display:grid;
    grid-template-columns: 1fr auto;
    gap:10px;
    align-items:center;
    margin:10px 0;
  }
  .tm-embed label{ font-size:12px; color:var(--muted); }
  .tm-embed .tm-value{
    font-variant-numeric: tabular-nums;
    text-align:right;
    font-size:12px;
    color:var(--text);
  }

  .tm-embed .tm-row.tm-range input[type="range"]{
    grid-column: 1 / -1;
    width:100%;
  }

  .tm-embed select,
  .tm-embed input[type="color"],
  .tm-embed button{ width:100%; }

  .tm-embed input[type="range"]{ accent-color: var(--accent); }

  .tm-embed select,
  .tm-embed button,
  .tm-embed input[type="color"]{
    background:#fff;
    border:1px solid var(--border);
    color:var(--text);
    border-radius:10px;
    padding:10px;
    box-shadow: 0 2px 10px rgba(0,0,0,.04);
  }
  .tm-embed button{ cursor:pointer; }
  .tm-embed .tm-primary{
    background:var(--accent);
    border-color:transparent;
    color:#fff;
    font-weight:650;
  }

  .tm-embed .tm-twoBtns{ grid-template-columns:1fr 1fr; }
  .tm-embed .tm-tiny{ font-size:11px; color:var(--muted); line-height:1.35; }

  .tm-embed .tm-canvas{
    position:relative;
    height:100%;
    background:#fff;
    overscroll-behavior: contain;
  }
  .tm-embed #tm-c{
    width:100%;
    height:100%;
    display:block;
    touch-action: none;
  }

  /* ✅ Summary title */
  .tm-embed .tm-summaryTitle{
    font-size:12px;
    color:var(--muted);
    letter-spacing:.2px;
    margin-bottom:10px;
  }

  /* ✅ HUD now lives INSIDE the left panel (not absolute overlay) */
  .tm-embed .tm-hudBottom{
    position: static;
    left:auto;
    bottom:auto;
    transform:none;

    background: transparent;
    border: 0;
    box-shadow: none;
    backdrop-filter: none;
    padding: 0;
    max-width: 100%;

    font-size:12px;
    color:var(--muted);
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    justify-content:flex-start;
    align-items:center;

    pointer-events:auto;
  }

  .tm-embed .tm-pill{
    display:inline-flex;
    gap:8px;
    align-items:center;
    padding:6px 10px;
    border-radius:999px;
    background:rgba(17,24,39,.03);
    border:1px solid var(--border);
    color:var(--text);
    font-size:12px;
  }
  .tm-embed .tm-pill b{ color:var(--text); }

  @media (max-width: 920px){
    .tm-embed .tm-wrap{
      grid-template-columns: 1fr;
      grid-template-rows:auto 1fr;
      height: min(1100px, 120vh);
      min-height: 920px;
    }
    .tm-embed .tm-panel{
      border-right:none;
      border-bottom:1px solid var(--border);
    }
  }
</style>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js?module";

  const host = document.getElementById("tm-embed");
  if(!host || host.dataset.tmMounted === "1") {
    /* prevent double-mount in Squarespace */
  } else {
    host.dataset.tmMounted = "1";

    const $ = (sel) => host.querySelector(sel);

    // ---- “Realism” constants (mm-ish units) ----
    const WALL_MM = 1.5;
    const LID_TOP_INSET_MM = 2;  // o kolik menší průměr (radius) – 2mm “ekvidistanta”
const LID_TOP_DROP_MM  = 3;  // o kolik níž zapustit (dolů)


    // Curled paper rim – outside
    const PAPER_CURL_R = 0.5;

    // One-piece metal “end-caps” – ultra-thin hint (~1mm)
    const METAL_LID_THICK_MM = 2.0;
    const METAL_LID_OVERHANG_MM = 0.8;
    const METAL_LID_ROLL_R = 0.35;

    const LID_CLEARANCE_MM = 0.8;
    const RADIAL_SEG = 140;
    const SHADOW_OPACITY = 0.20;

    // ---- DOM ----
    const ui = {
      type: $("#tm-type"),
      diameter: $("#tm-diameter"),
      height: $("#tm-height"),
      telRow: $("#tm-telRow"),
      telLidPct: $("#tm-telLidPct"),
      open: $("#tm-open"),
      material: $("#tm-material"),
      color: $("#tm-color"),
      reset: $("#tm-reset"),
      copy: $("#tm-copy"),

      diameterVal: $("#tm-diameterVal"),
      heightVal: $("#tm-heightVal"),
      telLidPctVal: $("#tm-telLidPctVal"),
      openVal: $("#tm-openVal"),

      hudBottom: $("#tm-hudBottom"),
      canvasWrap: $(".tm-canvas"),
    };

    const mm = (n)=> `${Math.round(n)} mm`;
    const pct = (n)=> `${Math.round(n)}%`;

    // ---- Three setup ----
    const canvas = $("#tm-c");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0xffffff, 1);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 6000);
    camera.position.set(260, 220, 360);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.enableZoom = true;
    controls.enablePan = true;

    // Stop Squarespace page scroll while zooming over the 3D area
    ui.canvasWrap.addEventListener("wheel", (e)=> e.preventDefault(), { passive:false });

    // Lights (white studio)
    scene.add(new THREE.HemisphereLight(0xffffff, 0xf3f4f6, 0.9));

    const key = new THREE.DirectionalLight(0xffffff, 0.9);
    key.position.set(500, 800, 300);
    key.castShadow = true;
    key.shadow.mapSize.set(2048, 2048);
    key.shadow.camera.near = 10;
    key.shadow.camera.far = 2500;
    key.shadow.camera.left = -700;
    key.shadow.camera.right = 700;
    key.shadow.camera.top = 700;
    key.shadow.camera.bottom = -700;
    scene.add(key);

    const fill = new THREE.DirectionalLight(0xffffff, 0.35);
    fill.position.set(-450, 260, -380);
    scene.add(fill);

    // Shadow catcher plane
    const shadowPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(2400, 2400),
      new THREE.ShadowMaterial({ opacity: SHADOW_OPACITY })
    );
    shadowPlane.rotation.x = -Math.PI/2;
    shadowPlane.position.y = -0.15;
    shadowPlane.receiveShadow = true;
    scene.add(shadowPlane);

    const root = new THREE.Group();
    scene.add(root);

    const parts = {
      base: null,
      lid: null,
      collar: null,
      metalTop: null,
      metalBottom: null,
      type: "two",
    };

    function disposeObject(obj){
      obj.traverse(o=>{
        if(o.geometry) o.geometry.dispose();
        if(o.material){
          if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose());
          else o.material.dispose();
        }
      });
    }

    function clearRoot(){
      while(root.children.length){
        const ch = root.children[0];
        disposeObject(ch);
        root.remove(ch);
      }
      parts.base = parts.lid = parts.collar = parts.metalTop = parts.metalBottom = null;
    }

    function makeWrapMaterials(kind, hex){
      const c = new THREE.Color(hex);
      let metalness = 0.0, roughness = 3.0;
      if(kind === "satin"){ metalness = 0.05; roughness = 0.35; }
      if(kind === "metal"){ metalness = 0.72; roughness = 0.22; }

      const outer = new THREE.MeshStandardMaterial({ color: c, metalness, roughness, side: THREE.FrontSide });

      const inner = new THREE.MeshStandardMaterial({
        color: c.clone().multiplyScalar(0.92),
        metalness: metalness * 0.55,
        roughness: Math.min(1, roughness + 0.10),
        side: THREE.BackSide
      });

      const edge = new THREE.MeshStandardMaterial({
        color: c.clone().multiplyScalar(0.98),
        metalness,
        roughness: Math.min(1, roughness + 0.06),
        side: THREE.DoubleSide
      });

      return { outer, inner, edge };
    }

    function makeMetalMaterials(hex = "#d7dbe3"){
      const c = new THREE.Color(hex);
      const outer = new THREE.MeshStandardMaterial({ color: c, metalness: 0.88, roughness: 0.24, side: THREE.FrontSide });
      const inner = new THREE.MeshStandardMaterial({ color: c.clone().multiplyScalar(0.86), metalness: 0.88, roughness: 0.32, side: THREE.BackSide });
      const edge  = new THREE.MeshStandardMaterial({ color: c, metalness: 0.9,  roughness: 0.24, side: THREE.DoubleSide });
      return { outer, inner, edge };
    }

    // Hollow tube with visible wall thickness + optional curled edge on outside rim
    function makeHollowTube({
      rOut, height, wall,
      mats,
      openTop=true, openBottom=true,
      closedTop=false, closedBottom=false,
      curlTop=false, curlBottom=false,
      curlR=PAPER_CURL_R
    }){
      const g = new THREE.Group();
      g.userData.height = height;

      const rIn = Math.max(0.1, rOut - wall);
      const innerH = Math.max(0.1, height - 2*wall);

      const outerWall = new THREE.Mesh(
        new THREE.CylinderGeometry(rOut, rOut, height, RADIAL_SEG, 1, true),
        mats.outer
      );
      outerWall.position.y = height/2;
      outerWall.castShadow = true;
      g.add(outerWall);

      const innerWall = new THREE.Mesh(
        new THREE.CylinderGeometry(rIn, rIn, innerH, RADIAL_SEG, 1, true),
        mats.inner
      );
      innerWall.position.y = height/2;
      g.add(innerWall);

      // Rims
      if(openTop && !closedTop){
        const ringTop = new THREE.Mesh(
          new THREE.RingGeometry(rIn, rOut, RADIAL_SEG),
          mats.edge
        );
        ringTop.rotation.x = -Math.PI/2;
        ringTop.position.y = height;
        ringTop.castShadow = true;
        g.add(ringTop);
      }
      if(openBottom && !closedBottom){
        const ringBot = new THREE.Mesh(
          new THREE.RingGeometry(rIn, rOut, RADIAL_SEG),
          mats.edge
        );
        ringBot.rotation.x = -Math.PI/2;
        ringBot.position.y = 0;
        ringBot.castShadow = true;
        g.add(ringBot);
      }

      // Caps (paper discs)
      if(closedBottom){
        const capB = new THREE.Mesh(
          new THREE.CylinderGeometry(rOut, rOut, wall, RADIAL_SEG),
          mats.edge
        );
        capB.position.y = wall/2;
        capB.castShadow = true;
        g.add(capB);
      }
 if(closedTop){
  // make the top disk ever-so-slightly smaller + offset to avoid z-fighting spikes
  const EPS_R = 0.4;   // 0.2–0.4 mm usually enough
  const EPS_Y = 0.3;   // tiny vertical offset

  const topMat = mats.edge.clone();
  topMat.polygonOffset = true;
  topMat.polygonOffsetFactor = -1;
  topMat.polygonOffsetUnits  = -1;

  const capT = new THREE.Mesh(
    new THREE.CylinderGeometry(Math.max(0.1, rOut - EPS_R), Math.max(0.1, rOut - EPS_R), wall, RADIAL_SEG),
    topMat
  );

  capT.position.y = (height - wall/2) - EPS_Y;
  capT.castShadow = true;
  g.add(capT);
}



      // Curled edges on OUTSIDE rim
      const minor = curlR * 0.65;
      const major = rOut + minor * 0.25;

    if(curlBottom && openBottom && !closedBottom){
  // Push curl further OUTSIDE so it reads as a real rolled edge
  const minor = curlR * 0.45;                // a bit slimmer = cleaner
  const major = rOut + minor * 0.55;         // more outside = more visible

  // Use a cloned material with polygonOffset to avoid z-fighting spikes
  const m = mats.outer.clone();
  m.polygonOffset = true;
  m.polygonOffsetFactor = -1;
  m.polygonOffsetUnits  = -1;

  const tor = new THREE.Mesh(
    new THREE.TorusGeometry(major, minor, 16, RADIAL_SEG),
    m
  );

  tor.rotation.x = Math.PI/2;

  // IMPORTANT: sit ON the bottom rim (slightly below), not above it
  tor.position.y = -minor * 0.25;

  tor.castShadow = true;
  g.add(tor);
}


      return g;
    }

    // One-piece metal end-cap: ultra-thin ~1mm “hint”
    function makeMetalEndCapHint({
      rTubeOut,
      thickness = METAL_LID_THICK_MM,
      overhang = METAL_LID_OVERHANG_MM,
      rollR = METAL_LID_ROLL_R,
      mats
    }){
      const g = new THREE.Group();
      g.userData.height = thickness;

      const rDisk = rTubeOut + overhang;

      const disk = new THREE.Mesh(
        new THREE.CylinderGeometry(rDisk, rDisk, thickness, RADIAL_SEG),
        mats.edge
      );
      disk.position.y = thickness/2;
      disk.castShadow = true;
      g.add(disk);

      const roll = new THREE.Mesh(
        new THREE.TorusGeometry(rDisk + rollR*0.15, rollR, 12, RADIAL_SEG),
        mats.outer
      );
      roll.rotation.x = Math.PI/2;
      roll.position.y = thickness - rollR*0.65;
      roll.castShadow = true;
      g.add(roll);

      return g;
    }

    function setClosedY(obj, y){
      obj.userData.closedY = y;
      obj.position.y = y;
    }

    function currentConfig(){
      return {
        type: ui.type.value,
        diameterMm: Number(ui.diameter.value),
        heightMm: Number(ui.height.value),
        telLidPct: Number(ui.telLidPct.value),
        openPct: Number(ui.open.value),
        material: ui.material.value,
        colorHex: ui.color.value,
        wallMm: WALL_MM
      };
    }

    function syncLabels(){
      ui.diameterVal.textContent = mm(ui.diameter.value);
      ui.heightVal.textContent = mm(ui.height.value);
      ui.telLidPctVal.textContent = pct(ui.telLidPct.value);
      ui.openVal.textContent = pct(ui.open.value);
      ui.telRow.style.display = (ui.type.value === "tel") ? "block" : "none";
    }

    function updateHUD(){
      const cfg = currentConfig();
      const typeLabel = cfg.type === "one" ? "One-piece" : (cfg.type === "two" ? "Base & lid" : "Telescopic");
      const matLabel  = cfg.material === "paper" ? "Matte paper" : (cfg.material === "satin" ? "Satin" : "Metallic");
      const extra     = cfg.type === "tel" ? ` · <b>Lid:</b> ${cfg.telLidPct}%` : "";

      ui.hudBottom.innerHTML = `
        <span class="tm-pill"><b>Construction</b> ${typeLabel}</span>
        <span class="tm-pill"><b>Ø</b> ${cfg.diameterMm} mm</span>
        <span class="tm-pill"><b>Height</b> ${cfg.heightMm} mm</span>
        <span class="tm-pill"><b>Finish</b> ${matLabel}</span>
        <span class="tm-pill"><b>Color</b> ${cfg.colorHex.toUpperCase()}</span>
        <span class="tm-pill"><b>Opening</b> ${cfg.openPct}%${extra}</span>
      `;
    }

    function resize(){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      if(w <= 0 || h <= 0) return;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }

    function buildModel(){
      clearRoot();

      const type = ui.type.value;
      const D = Number(ui.diameter.value);
      const H = Number(ui.height.value);
      const r = D/2;

      controls.minDistance = Math.max(40, r * 1.2);
      controls.maxDistance = Math.max(2200, r * 40 + H * 8);

      parts.type = type;

      const wrapMats = makeWrapMaterials(ui.material.value, ui.color.value);
      const metalMats = makeMetalMaterials("#D7DBE3");

      const y0 = 0;

      if(type === "one"){
        const body = makeHollowTube({
          rOut: r,
          height: H,
          wall: WALL_MM,
          mats: wrapMats,
          openTop: true,
          openBottom: true,
          closedTop: false,
          closedBottom: false,
          curlTop: false,
          curlBottom: false
        });
        body.position.y = y0;
        root.add(body);
        parts.base = body;

        const bottomCap = makeMetalEndCapHint({
          rTubeOut: r,
          thickness: METAL_LID_THICK_MM,
          overhang: METAL_LID_OVERHANG_MM,
          rollR: METAL_LID_ROLL_R,
          mats: metalMats
        });
        bottomCap.position.y = y0;
        root.add(bottomCap);
        parts.metalBottom = bottomCap;

        const topCap = makeMetalEndCapHint({
          rTubeOut: r,
          thickness: METAL_LID_THICK_MM,
          overhang: METAL_LID_OVERHANG_MM,
          rollR: METAL_LID_ROLL_R,
          mats: metalMats
        });

        const closedY = y0 + H - METAL_LID_THICK_MM;
        setClosedY(topCap, closedY);
        root.add(topCap);
        parts.metalTop = topCap;

        controls.target.set(0, H*0.55, 0);
      }

      if(type === "two"){
        const lidH = Math.max(35, Math.min(H*0.42, 140));
        const overlap = Math.max(14, Math.min(H*0.18, 40));
        const baseH = Math.max(35, H - lidH + overlap);

        const base = makeHollowTube({
          rOut: r,
          height: baseH,
          wall: WALL_MM,
          mats: wrapMats,
          openTop: true,
          openBottom: false,
          closedBottom: true,
          curlTop: true,
          curlBottom: false,
          curlR: PAPER_CURL_R
        });
        base.position.y = y0;
        root.add(base);
        parts.base = base;

        const rLid = r + (WALL_MM + LID_CLEARANCE_MM + 0.2);
        const lid = makeHollowTube({
          rOut: rLid,
          height: lidH,
          wall: WALL_MM,
          mats: wrapMats,
          openTop: false,
          openBottom: true,
          closedTop: true,
          curlBottom: true,
          curlR: PAPER_CURL_R
        });

        const closedY = y0 + (baseH - overlap);
        setClosedY(lid, closedY);
        root.add(lid);
        parts.lid = lid;

        controls.target.set(0, H*0.55, 0);
      }

      if(type === "tel"){
        const lidPct = Number(ui.telLidPct.value)/100;
        const lidH = Math.max(40, Math.min(H*lidPct, 320));
        const overlap = Math.max(16, Math.min(lidH*0.18, 55));
        const lowerVisible = Math.max(35, H - lidH + overlap);

        const baseH = Math.max(35, lowerVisible*0.72);
        const neckAbove = Math.max(12, lowerVisible - baseH);
        const neckInsert = Math.max(18, Math.min(baseH*0.45, 65));
        const neckH = neckAbove + neckInsert;

        const base = makeHollowTube({
          rOut: r,
          height: baseH,
          wall: WALL_MM,
          mats: wrapMats,
          openTop: true,
          openBottom: false,
          closedBottom: true,
          curlTop: true,
          curlR: PAPER_CURL_R
        });
        base.position.y = y0;
        root.add(base);
        parts.base = base;

        const neckR = Math.max(2, (r - WALL_MM - 1.1));
        const collar = makeHollowTube({
          rOut: neckR,
          height: neckH,
          wall: Math.max(1.0, WALL_MM*0.9),
          mats: wrapMats,
          openTop: true,
          openBottom: true,
          closedTop: false,
          closedBottom: false,
          curlTop: false,
          curlBottom: false
        });
        collar.position.y = y0 + (baseH - neckInsert);
        root.add(collar);
        parts.collar = collar;

        const rLid = r + (WALL_MM + LID_CLEARANCE_MM + 0.4);
        const lid = makeHollowTube({
          rOut: rLid,
          height: lidH,
          wall: WALL_MM,
          mats: wrapMats,
          openTop: false,
          openBottom: true,
          closedTop: true,
          curlBottom: true,
          curlR: PAPER_CURL_R
        });

        const closedY = y0 + (lowerVisible - overlap);
        setClosedY(lid, closedY);
        root.add(lid);
        parts.lid = lid;

        controls.target.set(0, H*0.55, 0);
      }

      applyOpen();
      updateHUD();
      resize();
    }

    function applyOpen(){
      const open = Number(ui.open.value)/100;
      const cfg = currentConfig();

      if(parts.type === "one" && parts.metalTop){
        const H = cfg.heightMm;
        const maxLift = Math.max(60, Math.min(H*0.7, 260));
        parts.metalTop.position.y = parts.metalTop.userData.closedY + open * maxLift;
      }

      if(parts.type === "two" && parts.lid){
        const H = cfg.heightMm;
        const maxLift = Math.max(70, Math.min(H*0.75, 320));
        parts.lid.position.y = parts.lid.userData.closedY + open * maxLift;
      }

      if(parts.type === "tel" && parts.lid){
        const H = cfg.heightMm;
        const maxLift = Math.max(90, Math.min(H*0.85, 380));
        parts.lid.position.y = parts.lid.userData.closedY + open * maxLift;
      }
    }

    function rebuild(){
      syncLabels();
      buildModel();
      renderer.render(scene, camera);
    }

    ["input","change"].forEach(evt=>{
      ui.type.addEventListener(evt, rebuild);
      ui.diameter.addEventListener(evt, rebuild);
      ui.height.addEventListener(evt, rebuild);
      ui.telLidPct.addEventListener(evt, rebuild);
      ui.material.addEventListener(evt, rebuild);
      ui.color.addEventListener(evt, rebuild);

      ui.open.addEventListener(evt, () => {
        syncLabels();
        applyOpen();
        updateHUD();
      });
    });

    ui.reset.addEventListener("click", () => {
      const cfg = currentConfig();
      const r = cfg.diameterMm/2;
      const H = cfg.heightMm;

      controls.target.set(0, H*0.55, 0);
      camera.position.set(r*5.2, H*1.1, r*6.2);
      controls.update();
      resize();
    });

    ui.copy.addEventListener("click", async () => {
      const payload = { ...currentConfig(), timestamp: new Date().toISOString() };
      const json = JSON.stringify(payload, null, 2);
      try{
        await navigator.clipboard.writeText(json);
        ui.copy.textContent = "Copied ✓";
        setTimeout(()=> ui.copy.textContent = "Copy configuration JSON", 900);
      }catch(e){
        window.prompt("Copy JSON:", json);
      }
    });

    const ro = new ResizeObserver(() => resize());
    ro.observe(host);

    window.addEventListener("resize", resize);

    // ---- Init ----
    syncLabels();
    buildModel();
    resize();

    setTimeout(()=>{ resize(); }, 120);
    setTimeout(()=>{ resize(); }, 420);
    setTimeout(()=>{ resize(); }, 900);

    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  }
</script>
